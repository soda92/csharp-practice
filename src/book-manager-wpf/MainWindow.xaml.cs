using book_manager_wpf.Models;
using book_manager_wpf.Services;
using System;
using System.Collections.ObjectModel;
using System.Windows;

namespace book_manager_wpf
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window // Removed IDisposable as it's not fully implemented and BookService manages its own resources
    {
        private BookService _bookService;
        private ObservableCollection<Book> _books;

        public MainWindow()
        {
            InitializeComponent();
            _bookService = new BookService();
            _books = new ObservableCollection<Book>();
            dgBooks.ItemsSource = _books;
            dgBooks.SelectionChanged += DgBooks_SelectionChanged;
        }

        private async void Window_Loaded(object sender, RoutedEventArgs e)
        {
            try
            {
                await LoadBooks();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading books: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task LoadBooks()
        {
            var books = await _bookService.GetBooksAsync();
            _books.Clear();
            if (books != null)
            {
                foreach (var book in books)
                {
                    _books.Add(book);
                }
            }
        }

        private void DgBooks_SelectionChanged(object sender, System.Windows.Controls.SelectionChangedEventArgs e)
        {
            if (dgBooks.SelectedItem is Book selectedBook)
            {
                txtISBN.Text = selectedBook.ISBN;
                txtName.Text = selectedBook.Name;
                txtAuthor.Text = selectedBook.Author;
                txtCount.Text = selectedBook.Count.ToString();
            }
        }

        private async void AddButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(txtISBN.Text) || string.IsNullOrWhiteSpace(txtName.Text) ||
                    string.IsNullOrWhiteSpace(txtAuthor.Text) || !int.TryParse(txtCount.Text, out int count) || count < 0)
                {
                    MessageBox.Show("Please fill in all fields with valid values. Count must be a non-negative number.", "Validation Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                var book = new Book
                {
                    ISBN = txtISBN.Text,
                    Name = txtName.Text,
                    Author = txtAuthor.Text,
                    Count = count
                };

                await _bookService.SaveBookAsync(book);
                // If SaveBookAsync assigns an ID, the 'book' object in _books might need to be the one returned by SaveBookAsync or re-fetched
                // For simplicity with SQLite-net-pcl auto-increment, re-loading or adding the passed object is usually fine.
                // To be absolutely sure the ID is reflected if it's generated by DB and needed immediately:
                // _books.Add(book); // The ID will be 0 here if it's a new book and ID is generated by DB on insert.
                // For a more robust way to get the ID, you might need SaveBookAsync to return the saved book object.
                // However, for this example, adding the current book object and then reloading is also an option.
                // A simple way is to just add it, and if ID is critical for display immediately, adjust SaveBookAsync.
                // For now, we'll add and then clear/reload for simplicity to ensure DataGrid has the ID if it was generated.
                await LoadBooks(); // Reload to get the book with its ID from the database
                ClearInputFields();
                MessageBox.Show("Book added successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error adding book: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async void ModifyButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var selectedBook = dgBooks.SelectedItem as Book;
                if (selectedBook == null)
                {
                    MessageBox.Show("Please select a book to modify.", "Selection Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                if (string.IsNullOrWhiteSpace(txtISBN.Text) || string.IsNullOrWhiteSpace(txtName.Text) ||
                    string.IsNullOrWhiteSpace(txtAuthor.Text) || !int.TryParse(txtCount.Text, out int count) || count < 0)
                {
                    MessageBox.Show("Please ensure all fields for the selected book are filled with valid values. Count must be a non-negative number.", "Validation Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                selectedBook.ISBN = txtISBN.Text;
                selectedBook.Name = txtName.Text;
                selectedBook.Author = txtAuthor.Text;
                selectedBook.Count = count;

                await _bookService.SaveBookAsync(selectedBook);
                // The ObservableCollection should update the specific item if Book implements INotifyPropertyChanged.
                // If not, dgBooks.Items.Refresh() is a way to force UI update.
                // For more fine-grained updates, INotifyPropertyChanged on Book model is recommended.
                // For now, refreshing the specific item or the whole list works.
                int selectedIndex = _books.IndexOf(selectedBook);
                if (selectedIndex != -1)
                {
                    // To ensure the UI updates if INotifyPropertyChanged is not implemented on Book:
                    _books.RemoveAt(selectedIndex);
                    _books.Insert(selectedIndex, selectedBook);
                    dgBooks.SelectedItem = selectedBook; // Re-select the item
                }
                else { dgBooks.Items.Refresh(); /* Fallback */ }
                
                ClearInputFields();
                MessageBox.Show("Book modified successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error modifying book: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async void DeleteButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var selectedBook = dgBooks.SelectedItem as Book;
                if (selectedBook != null)
                {
                    var result = MessageBox.Show($"Are you sure you want to delete '{selectedBook.Name}'?", "Confirm Delete", MessageBoxButton.YesNo, MessageBoxImage.Warning);
                    if (result == MessageBoxResult.Yes)
                    {
                        await _bookService.DeleteBookAsync(selectedBook);
                        _books.Remove(selectedBook);
                        ClearInputFields();
                        MessageBox.Show("Book deleted successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
                    }
                }
                else
                {
                    MessageBox.Show("Please select a book to delete.", "Selection Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error deleting book: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        private void ClearInputFields()
        {
            txtISBN.Clear(); txtName.Clear(); txtAuthor.Clear(); txtCount.Clear();
            dgBooks.SelectedItem = null;
        }
    }
 }